# -*- coding: utf-8 -*-
"""Calculadora de Redes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vAH1lKt9A_9cp7FFZT7w2Rr2PN2XyiYa
"""

exemplo_primeiro_octeto = '1-255'
exemplo_demais_octetos = '0-255'
exemplo_rede = '8-30'
ip_user = rede_user = 0
limite_octetos_final = 4
rede_tamanho_minimo = 8
rede_tamanho_maximo = 32
lista_octetos_validos_nao_validos = []

# HOW MANY OCTETS WERE TYPED
def verificar_octetos(a):
  ponto = definir_primeiro_octeto = 0
  quantidade_octetos_digitados = 4
  definir_segundo_octeto = 1
  definir_terceiro_octeto = 2
  limite_octetos = 4
  lista_primeiro_octeto = []
  lista_segundo_octeto = []
  lista_terceiro_octeto = []
  lista_quarto_octeto = []
  separar_octetos = '.'
  primeiro_octeto_digitado = segundo_octeto_digitado = terceiro_octeto_digitado = quarto_octeto_digitado = False

  # SEPARATES EACH OCTETS BY DOTS/PERIODS, ADDING EACH DIGIT IN A LISTA
  for ip in a:
    if(ip == separar_octetos):
      ponto += 1
    else:
      if(ponto == definir_primeiro_octeto):
        lista_primeiro_octeto.append(ip)
      elif(ponto == definir_segundo_octeto):
        lista_segundo_octeto.append(ip)
      elif(ponto == definir_terceiro_octeto):
        lista_terceiro_octeto.append(ip)
      else:
        lista_quarto_octeto.append(ip)

  # DEFINES HOW MANY AND WHICH OCTETS WERE TYPED
  if(len(lista_primeiro_octeto) == 0):
    quantidade_octetos_digitados -= 1
    if(len(lista_segundo_octeto) == 0):
      quantidade_octetos_digitados -= 1
      if(len(lista_terceiro_octeto) == 0):
        quantidade_octetos_digitados -= 1
        if(len(lista_quarto_octeto) == 0):
          # NO OCTET WERE TYPED
          quantidade_octetos_digitados -= 1
        else:
          # 1ST, 2ND AND 3RD OCTETS WEREN'T TYPED
          quarto_octeto_digitado = True
      elif(len(lista_quarto_octeto) == 0):
        # 1ST, 2ND AND 4TH OCTETS WEREN'T TYPED
        quantidade_octetos_digitados -= 1
        terceiro_octeto_digitado = True
      else:
        # 1ST AND 2ND OCTETS WEREN'T TYPED
        terceiro_octeto_digitado = quarto_octeto_digitado = True
    elif(len(lista_terceiro_octeto) == 0):
      quantidade_octetos_digitados -= 1
      if(len(lista_quarto_octeto) == 0):
        # 1ST, 3RD AND 4TH OCTETS WEREN'T TYPED
        quantidade_octetos_digitados -= 1
        segundo_octeto_digitado = True
      else:
        # 1ST AND 3RD OCTETS WEREN'T TYPED
        segundo_octeto_digitado = quarto_octeto_digitado = True
    elif(len(lista_quarto_octeto) == 0):
      # 1ST AND 4TH OCTETS WEREN'T TYPED
      quantidade_octetos_digitados -= 1
      segundo_octeto_digitado = terceiro_octeto_digitado = True
    else:
      # 1ST OCTET WWASN'T TYPED
      segundo_octeto_digitado = terceiro_octeto_digitado = quarto_octeto_digitado = True
  elif(len(lista_segundo_octeto) == 0):
    quantidade_octetos_digitados -= 1
    if(len(lista_terceiro_octeto) == 0):
      quantidade_octetos_digitados -= 1
      if(len(lista_quarto_octeto) == 0):
        # 2ND, 3RD AND 4TH OCTETS WEREN'T TYPED
        quantidade_octetos_digitados -= 1
        primeiro_octeto_digitado = True
      else:
        # 2ND AND 3RD OCTETS WEREN'T TYPED
        primeiro_octeto_digitado = quarto_octeto_digitado = True
    elif(len(lista_quarto_octeto) == 0):
      # 2ND AND 4TH OCTETS WEREN'T TYPED
      quantidade_octetos_digitados -= 1
      primeiro_octeto_digitado = terceiro_octeto_digitado = True
    else:
      # 2ND OCTET WASN'T TYPED
      primeiro_octeto_digitado = terceiro_octeto_digitado = quarto_octeto_digitado = True
  elif(len(lista_terceiro_octeto) == 0):
    quantidade_octetos_digitados -= 1
    if(len(lista_quarto_octeto) == 0):
      # 3RD AND 4TH OCTETS WEREN'T TYPED
      quantidade_octetos_digitados -= 1
      primeiro_octeto_digitado = segundo_octeto_digitado = True
    else:
      # 3RD OCTET WASN'T TYPED
      primeiro_octeto_digitado = segundo_octeto_digitado = quarto_octeto_digitado = True
  elif(len(lista_quarto_octeto) == 0):
    # 4TH OCTET WASN'T TYPED
    quantidade_octetos_digitados -= 1
    primeiro_octeto_digitado = segundo_octeto_digitado = terceiro_octeto_digitado = True
  elif(ponto >= limite_octetos):
    # MORE THAN 4 OCTETS WERE TYPED
    quantidade_octetos_digitados = ponto + 1
  else:
    primeiro_octeto_digitado = segundo_octeto_digitado = terceiro_octeto_digitado = quarto_octeto_digitado = True

  lista_status_octetos = [primeiro_octeto_digitado, segundo_octeto_digitado, terceiro_octeto_digitado, quarto_octeto_digitado]

  return lista_status_octetos, lista_primeiro_octeto, lista_segundo_octeto, lista_terceiro_octeto, lista_quarto_octeto, quantidade_octetos_digitados

# VERIFIES WHICH OCTETS HAS JUST NUMBERS
def converter_ip(b, c, d, e):
  primeiro_octeto_so_numeros = segundo_octeto_so_numeros = terceiro_octeto_so_numeros = quarto_octeto_so_numeros = False
  range_ord_min = 48
  range_ord_max = 57
  quantidade_octetos_so_numeros = 4
  lista_octetos_validos_nao_validos = []

  for digito_primeiro_octeto in b:
    if(ord(digito_primeiro_octeto) in range(range_ord_min, range_ord_max + 1)):
      primeiro_octeto_so_numeros = True
    else:
      quantidade_octetos_so_numeros -= 1
      break

  for digito_segundo_octeto in c:
    if(ord(digito_segundo_octeto) in range(range_ord_min, range_ord_max + 1)):
      segundo_octeto_so_numeros = True
    else:
      quantidade_octetos_so_numeros -= 1
      break

  for digito_terceiro_octeto in d:
    if(ord(digito_terceiro_octeto) in range(range_ord_min, range_ord_max + 1)):
      terceiro_octeto_so_numeros = True
    else:
      quantidade_octetos_so_numeros -= 1
      break

  for digito_quarto_octeto in e:
    if(ord(digito_quarto_octeto) in range(range_ord_min, range_ord_max + 1)):
      quarto_octeto_so_numeros = True
    else:
      quantidade_octetos_so_numeros -= 1
      break

  lista_octetos_validos_nao_validos = [primeiro_octeto_so_numeros, segundo_octeto_so_numeros, terceiro_octeto_so_numeros, quarto_octeto_so_numeros]

  return lista_octetos_validos_nao_validos, quantidade_octetos_so_numeros

# VERIFIES WHICH OCTET IS ON THE IDEAL RANGE
def verificar_faixa_ip(f, g, h, i):
  primeiro_octeto_na_faixa = segundo_octeto_na_faixa = terceiro_octeto_na_faixa = quarto_octeto_na_faixa = False
  limite_numero_maximo = 255
  limite_numero_minimo = 1
  quantidade_octetos_faixa_ideal = 4
  lista_octetos_faixa = []

  if((f < limite_numero_minimo) or (f > limite_numero_maximo)):
    quantidade_octetos_faixa_ideal -= 1
    if(g > limite_numero_maximo):
      quantidade_octetos_faixa_ideal -= 1
      if(h > limite_numero_maximo):
        quantidade_octetos_faixa_ideal -= 1
        if(i > limite_numero_maximo):
          # NO OCTET IS ON THE IDEAL RANGE
          quantidade_octetos_faixa_ideal -= 1
        else:
          # 1ST, 2ND AND 3RD OCTETS AREN'T ON THE IDEAL RANGE
          quarto_octeto_na_faixa = True
      elif(i > limite_numero_maximo):
        # 1ST, 2ND AND 4TH OCTETS AREN'T ON THE IDEAL RANGE
        quantidade_octetos_faixa_ideal -= 1
        terceiro_octeto_na_faixa = True
      else:
        # 1º AND 2ND OCTETS AREN'T ON THE IDEAL RANGE
        terceiro_octeto_na_faixa = quarto_octeto_na_faixa = True
    elif(h > limite_numero_maximo):
      quantidade_octetos_faixa_ideal -= 1
      if(i > limite_numero_maximo):
        # 1ST, 2ND AND 4TH OCTETS AREN'T ON THE IDEAL RANGE
        quantidade_octetos_faixa_ideal -= 1
        segundo_octeto_na_faixa = True
      else:
        # 1ST AND 3RD OCTETS AREN'T ON THE IDEAL RANGE
        segundo_octeto_na_faixa = quarto_octeto_na_faixa = True
    elif(i > limite_numero_maximo):
      # 1ST AND 4TH OCTETS AREN'T ON THE IDEAL RANGE
      quantidade_octetos_faixa_ideal -= 1
      segundo_octeto_na_faixa = terceiro_octeto_na_faixa = True
    else:
      # 1ST OCTET ISN'T ON THE IDEAL RANGE
      segundo_octeto_na_faixa = terceiro_octeto_na_faixa = quarto_octeto_na_faixa = True
  elif(g > limite_numero_maximo):
    quantidade_octetos_faixa_ideal -= 1
    if(h > limite_numero_maximo):
      quantidade_octetos_faixa_ideal -= 1
      if(i > limite_numero_maximo):
        # 2ND, 3RD AND 4TH OCTETS AREN'T ON THE IDEAL RANGE
        quantidade_octetos_faixa_ideal -= 1
        primeiro_octeto_na_faixa = True
      else:
        # 2ND AND 3RD OCTETS AREN'T ON THE IDEAL RANGE
        primeiro_octeto_na_faixa = quarto_octeto_na_faixa = True
    elif(i > limite_numero_maximo):
      # 2ND AND 4TH OCTETS AREN'T ON THE IDEAL RANGE
      quantidade_octetos_faixa_ideal -= 1
      primeiro_octeto_na_faixa = terceiro_octeto_na_faixa = True
    else:
      # 2ND OCTETS ISN'T ON THE IDEAL RANGE
      primeiro_octeto_na_faixa = terceiro_octeto_na_faixa = quarto_octeto_na_faixa = True
  elif(h > limite_numero_maximo):
    quantidade_octetos_faixa_ideal -= 1
    if(i > limite_numero_maximo):
      # 3RD AND 4TH OCTETS AREN'T ON THE IDEAL RANGE
      quantidade_octetos_faixa_ideal -= 1
      primeiro_octeto_na_faixa = segundo_octeto_na_faixa = True
    else:
      # 3RD OCTETS ISN'T ON THE IDEAL RANGE
      primeiro_octeto_na_faixa = segundo_octeto_na_faixa = quarto_octeto_na_faixa = True
  elif(i > limite_numero_maximo):
    # 4TH OCTETS ISN'T ON THE IDEAL RANGE
    quantidade_octetos_faixa_ideal -= 1
    primeiro_octeto_na_faixa = segundo_octeto_na_faixa = terceiro_octeto_na_faixa = True
  else:
    primeiro_octeto_na_faixa = segundo_octeto_na_faixa = terceiro_octeto_na_faixa = quarto_octeto_na_faixa = True

  lista_octetos_faixa = [primeiro_octeto_na_faixa, segundo_octeto_na_faixa, terceiro_octeto_na_faixa, quarto_octeto_na_faixa]

  return lista_octetos_faixa, quantidade_octetos_faixa_ideal

# VERIFIES IF THERE IS JUST NUMBERS ON THE CIDR
def verificar_rede(j):
  rede_so_numeros = True

  try:
    j = int(j)
  except ValueError:
    rede_so_numeros = False

  return rede_so_numeros, j

# CALCULATES THE SUBNET MASK
def mascara_de_rede(k):
  limite_bits = 8
  contador_bits_segundo_octeto = contador_bits_terceiro_octeto = contador_bits_quarto_octeto = 0
  soma_bits_segundo_octeto = soma_bits_terceiro_octeto = soma_bits_quarto_octeto = 0
  soma_bits_primeiro_octeto = 255
  base_bits_segundo_octeto = base_bits_terceiro_octeto = base_bits_quarto_octeto = 128

  for contar_bits in range(k):
    if(contar_bits < limite_bits):
      continue
      # AS THE CIDR CAN'T BE LESS THAN 8,
      # THE SUM OF THE BITS FROM THE 1ST OCTET IS ALWAYS 255
    elif(contar_bits < limite_bits * 2):
      contador_bits_segundo_octeto += 1
    elif(contar_bits < limite_bits * 3):
      contador_bits_terceiro_octeto += 1
    else:
      contador_bits_quarto_octeto += 1

  for bits_segundo_octeto in range(contador_bits_segundo_octeto):
    soma_bits_segundo_octeto += base_bits_segundo_octeto
    base_bits_segundo_octeto = base_bits_segundo_octeto//2

  for bits_terceiro_octeto in range(contador_bits_terceiro_octeto):
    soma_bits_terceiro_octeto += base_bits_terceiro_octeto
    base_bits_terceiro_octeto = base_bits_terceiro_octeto//2

  for bits_quarto_octeto in range(contador_bits_quarto_octeto):
    soma_bits_quarto_octeto += base_bits_quarto_octeto
    base_bits_quarto_octeto = base_bits_quarto_octeto//2

  return soma_bits_primeiro_octeto, soma_bits_segundo_octeto, soma_bits_terceiro_octeto, soma_bits_quarto_octeto

# CALCULATES NETWORK ADDRESS, BROADCAST, 1ST AND LAST USABLE IP
def rede_broadcast_ip_valido(l, m, n, o, p):
  maximo_numeros_ip = 256
  maximo_bits_total = 32
  quantidade_intervalos = broadcast_ip = rede_ip = 0
  lista_rede = []
  lista_broadcast = []
  lista_primeiro_ip_válido = []
  lista_ultimo_ip_valido = []

  if(p < maximo_bits_total//2):
    # HOW MANY BITS ARE ON ON THE 2ND OCTET
    bits_desligados = (maximo_bits_total//2) - p
    quantidade_intervalos = maximo_numeros_ip//2**bits_desligados
    intervalo = maximo_numeros_ip//quantidade_intervalos

    for intervalos_segundo_octeto in range(0, maximo_numeros_ip + 1, intervalo):
      if(m < intervalos_segundo_octeto):
        broadcast_ip = intervalos_segundo_octeto - 1
        rede_ip = intervalos_segundo_octeto - intervalo
        break

    lista_rede.extend([l, rede_ip, 0, 0])
    lista_primeiro_ip_válido.extend([l, rede_ip, 0, 1])
    lista_ultimo_ip_valido.extend([l, broadcast_ip, maximo_numeros_ip - 1, maximo_numeros_ip - 2])
    lista_broadcast.extend([l, broadcast_ip, maximo_numeros_ip - 1, maximo_numeros_ip - 1])

  elif(p < (maximo_bits_total//4)*3):
    # HOW MANY BITS ARE ON ON THE 3RD OCTET
    bits_desligados = ((maximo_bits_total//4)*3) - p
    quantidade_intervalos = maximo_numeros_ip//2**bits_desligados
    intervalo = maximo_numeros_ip//quantidade_intervalos

    for intervalos_terceiro_octeto in range(0, maximo_numeros_ip + 1, intervalo):
      if(n < intervalos_terceiro_octeto):
        broadcast_ip = intervalos_terceiro_octeto - 1
        rede_ip = intervalos_terceiro_octeto - intervalo
        break

    lista_rede.extend([l, m, rede_ip, 0])
    lista_primeiro_ip_válido.extend([l, m, rede_ip, 1])
    lista_ultimo_ip_valido.extend([l, m, broadcast_ip, maximo_numeros_ip - 2])
    lista_broadcast.extend([l, m, broadcast_ip, maximo_numeros_ip - 1])

  else:
    # HOW MANY BITS ARE ON ON THE 4TH OCTET
    bits_desligados = maximo_bits_total - p
    quantidade_intervalos = maximo_numeros_ip//2**bits_desligados
    intervalo = maximo_numeros_ip//quantidade_intervalos

    for intervalos_quarto_octeto in range(0, maximo_numeros_ip + 1, intervalo):
      if(o < intervalos_quarto_octeto):
        broadcast_ip = intervalos_quarto_octeto - 1
        rede_ip = intervalos_quarto_octeto - intervalo
        break

    lista_rede.extend([l, m, n, rede_ip])
    lista_primeiro_ip_válido.extend([l, m, n, rede_ip + 1])
    lista_ultimo_ip_valido.extend([l, m, n, broadcast_ip - 1])
    lista_broadcast.extend([l, m, n, broadcast_ip])

  return lista_rede, lista_primeiro_ip_válido, lista_ultimo_ip_valido, lista_broadcast

# VERIFIES THE IP CLASS, BASED ON THE 1ST OCTET
def classe_ip(q):
  classe_a = 127
  classe_b = 191
  classe_c = 223
  classe_d = 239
  classe_e = 255
  classe = None

  if(q <= classe_a):
    classe = 'A'
  elif(q <= classe_b):
    classe = 'B'
  elif(q <= classe_c):
    classe = 'C'
  elif(q <= classe_d):
    classe = 'D'
  else:
    classe = 'E'

  return classe

# VERIFIES IF THE IP IS PRIVATE OR PUBLIC
def ip_privado_publico(r, s, t, u, v):
  ip_classe_a = 'A'
  ip_classe_b = 'B'
  ip_classe_c = 'C'
  ip_classe_d = 'D'
  ip_classe_E = 'E'
  tipo_de_ip = None
  nao_disponivel = 'NOT AVAILABLE'
  privado = 'PRIVATE'
  publico = 'PUBLIC'

  if(v == ip_classe_a):
    if(r == 10):
      tipo_de_ip = privado
    else:
      tipo_de_ip = publico
  elif(v == ip_classe_b):
    if(r == 172):
      if((s >= 16) or (s <= 31)):
        tipo_de_ip = privado
      else:
        tipo_de_ip = publico
    else:
      tipo_de_ip = publico
  elif(v == ip_classe_c):
    if(r == 192):
      if(s == 168):
        tipo_de_ip = privado
      else:
        tipo_de_ip = publico
    else:
      tipo_de_ip = publico
  else:
    tipo_de_ip = nao_disponivel

  return tipo_de_ip

# DEFINES WHICH SUFIX WILL BE USED
def definir_sufixo(w):
  lista_sufixos = []
  sufixo = None

  for posicao in w:
    if(posicao == 1):
      sufixo = 'st'
    elif(posicao == 2):
      sufixo = 'nd'
    elif(posicao == 3):
      sufixo = 'rd'
    else:
      sufixo = 'th'
    lista_sufixos.append(sufixo)

  return lista_sufixos

if __name__ == '__main__':
  print('Welcome user!\nThis program is a IPv4 subnet calculator!')
  print('When you type the IP and CIDR, it will calculate:')
  print('Subnet Mask\nCIDR\n1st usable IP\nLast usable IP\nBroadcast\nIP Class\nPRIVATE or PUBLIC IP')
  print('-' * 30)

  while(True):
    print(f'To calculate, please type the desired IP, in the following format:')
    print(f'{exemplo_primeiro_octeto}.{exemplo_demais_octetos}.{exemplo_demais_octetos}.{exemplo_demais_octetos}:')
    ip_user = input()
    print('-' * 30)

    lista_status_octetos_final, primeiro_octeto, segundo_octeto, terceiro_octeto, quarto_octeto, quantidade_octetos_final = verificar_octetos(ip_user)
    if(quantidade_octetos_final < limite_octetos_final):
      lista_octetos_nao_validos = []
      for octetos_validos_nao_validos in range(len(lista_status_octetos_final)):
        if(lista_status_octetos_final[octetos_validos_nao_validos] == False):
          octeto_nao_valido = octetos_validos_nao_validos + 1
          lista_octetos_nao_validos.append(octeto_nao_valido)
          lista_sufixos_final = definir_sufixo(lista_octetos_nao_validos)
      if(quantidade_octetos_final == limite_octetos_final - 1):
        print(f"Error! You didn't typed the {lista_octetos_nao_validos[0]}{lista_sufixos_final[0]} octet!")
      elif(quantidade_octetos_final == limite_octetos_final - 2):
        print(f"Error! You didn't typed the {lista_octetos_nao_validos[0]}{lista_sufixos_final[0]} and {lista_octetos_nao_validos[1]}{lista_sufixos_final[1]} octets!")
      elif(quantidade_octetos_final == limite_octetos_final - 3):
        print(f"Error! You didn't typed the {lista_octetos_nao_validos[0]}{lista_sufixos_final[0]}, {lista_octetos_nao_validos[1]}{lista_sufixos_final[1]} and {lista_octetos_nao_validos[2]}{lista_sufixos_final[2]} octets!")
      else:
        print("Error! You didn't typed any octet!")
    elif(quantidade_octetos_final > limite_octetos_final):
      print(f'Error! You typed {quantidade_octetos_final} octets!')
      print(f"It's only accepted {limite_octetos_final} octets!")
    else:
      lista_octetos_validos_nao_validos, quantidade_octetos_so_numeros_final = converter_ip(primeiro_octeto, segundo_octeto, terceiro_octeto, quarto_octeto)
      if(quantidade_octetos_so_numeros_final < limite_octetos_final):
        lista_octetos_com_caracteres = []
        for octetos_com_sem_caracteres in range(len(lista_octetos_validos_nao_validos)):
          if(lista_octetos_validos_nao_validos[octetos_com_sem_caracteres] == False):
            octeto_com_caractere = octetos_com_sem_caracteres + 1
            lista_octetos_com_caracteres.append(octeto_com_caractere)
            lista_sufixos_final = definir_sufixo(lista_octetos_com_caracteres)
        if(quantidade_octetos_so_numeros_final == limite_octetos_final - 1):
          print(f"Error! You didn't typed just numbers on the {lista_octetos_com_caracteres[0]}{lista_sufixos_final[0]} octet!")
        elif(quantidade_octetos_so_numeros_final == limite_octetos_final - 2):
          print(f"Error! You didn't typed just numbers on the {lista_octetos_com_caracteres[0]}{lista_sufixos_final[0]} and {lista_octetos_com_caracteres[1]}{lista_sufixos_final[1]} octets!")
        elif(quantidade_octetos_so_numeros_final == limite_octetos_final - 3):
          print(f"Error! You didn't typed just numbers on the {lista_octetos_com_caracteres[0]}{lista_sufixos_final[0]}, {lista_octetos_com_caracteres[1]}{lista_sufixos_final[1]} and {lista_octetos_com_caracteres[2]}{lista_sufixos_final[2]} octets!")
        else:
          print("Error! You didn't typed just numbers on any octet!")
      else:
        primeiro_octeto = int(''.join(primeiro_octeto))
        segundo_octeto = int(''.join(segundo_octeto))
        terceiro_octeto = int(''.join(terceiro_octeto))
        quarto_octeto = int(''.join(quarto_octeto))
        lista_octetos_na_faixa_ou_nao, quantidade_octetos_na_faixa_final = verificar_faixa_ip(primeiro_octeto, segundo_octeto, terceiro_octeto, quarto_octeto)
        if(quantidade_octetos_na_faixa_final < limite_octetos_final):
          lista_octetos_nao_na_faixa = []
          for octetos_na_faixa_ou_nao in range(len(lista_octetos_na_faixa_ou_nao)):
            if(lista_octetos_na_faixa_ou_nao[octetos_na_faixa_ou_nao] == False):
              octeto_nao_na_faixa = octetos_na_faixa_ou_nao + 1
              lista_octetos_nao_na_faixa.append(octeto_nao_na_faixa)
              lista_sufixos_final = definir_sufixo(lista_octetos_nao_na_faixa)
          if(quantidade_octetos_na_faixa_final == limite_octetos_final - 1):
            print(f"Error! You didn't typed the {lista_octetos_nao_na_faixa[0]}{lista_sufixos_final[0]} octet on the ideal range!")
          elif(quantidade_octetos_na_faixa_final == limite_octetos_final - 2):
            print(f"Error! You didn't typed the {lista_octetos_nao_na_faixa[0]}{lista_sufixos_final[0]} and {lista_octetos_nao_na_faixa[1]}{lista_sufixos_final[1]} octets on the ideal range!")
          elif(quantidade_octetos_na_faixa_final == limite_octetos_final - 3):
            print(f"Error! You didn't typed the {lista_octetos_nao_na_faixa[0]}{lista_sufixos_final[0]}, {lista_octetos_nao_na_faixa[1]}{lista_sufixos_final[1]} and {lista_octetos_nao_na_faixa[2]}{lista_sufixos_final[2]} octets on the ideal range!")
          else:
            print('Error! No octet that you typed is on the ideal range!')
        else:
          break
    print('Please, try again!')
    print('-' * 30)

  while(True):
    print(f'Now, what is this IP CIDR?')
    print(f'Usable values: {exemplo_rede}:')
    rede_user = input()
    print('-' * 30)

    rede_so_numeros_final, rede = verificar_rede(rede_user)
    if(rede_so_numeros_final == False):
      print("Error! You didn't typed just numbers!")
    elif(rede < rede_tamanho_minimo):
      print('Error! You typed the CIDR bellow the minimum value!')
    elif(rede > rede_tamanho_maximo - 2):
      print('Error! You typed the CIDR above the maximum value!')
    else:
      break
    print('Please, try again!')
    print('-' * 30)

  mascara_primeiro_octeto, mascara_segundo_octeto, mascara_terceiro_octeto, mascara_quarto_octeto = mascara_de_rede(rede)
  rede_final, primeiro_ip_valido, ultimo_ip_valido, broadcast_final = rede_broadcast_ip_valido(primeiro_octeto, segundo_octeto, terceiro_octeto, quarto_octeto, rede)
  classe_final = classe_ip(primeiro_octeto)
  tipo_de_ip_final = ip_privado_publico(primeiro_octeto, segundo_octeto, terceiro_octeto, quarto_octeto, classe_final)

  print(f'IP and CIDR: {primeiro_octeto}.{segundo_octeto}.{terceiro_octeto}.{quarto_octeto}/{rede}')
  print(f'Subnet Mask: {mascara_primeiro_octeto}.{mascara_segundo_octeto}.{mascara_terceiro_octeto}.{mascara_quarto_octeto}')
  print(f'Network Address: {rede_final[0]}.{rede_final[1]}.{rede_final[2]}.{rede_final[3]}')
  print(f'1st usable IP: {primeiro_ip_valido[0]}.{primeiro_ip_valido[1]}.{primeiro_ip_valido[2]}.{primeiro_ip_valido[3]}')
  print(f'Last usable IP: {ultimo_ip_valido[0]}.{ultimo_ip_valido[1]}.{ultimo_ip_valido[2]}.{ultimo_ip_valido[3]}')
  print(f'Broadcast: {broadcast_final[0]}.{broadcast_final[1]}.{broadcast_final[2]}.{broadcast_final[3]}')
  print(f'IP Class: {classe_final}')
  print(f'IP Type: {tipo_de_ip_final}')

"""https://www.bosontreinamentos.com.br/hardware/tabela-ascii/"""